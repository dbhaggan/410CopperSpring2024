<html>
  <head>
    <style>
      h1 {
        color: blue
      }
      p { 
        color: gold
      }
    </style>
  </head>
  <body>
    
    <h1> Creates sheets here </h1>
    <p> Click the "Generate" button to create a score and click again to create another </p> 

    <div id="generatedScore"></div> 

    <button onclick = "runSheetGenerator()"> Generate </button> 


    
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <script>

    function runSheetGenerator(){

        let existingScore = document.getElementById("generatedScore"); 
        if(existingScore){
        existingScore.parentNode.removeChild(existingScore); 
        }

        // Adds a new div/svg element with same name to house Score 
        let newScore = document.createElement("div"); 
        newScore.id = "generatedScore"; 
        document.body.appendChild(newScore); 


        const {        
        Renderer, Stave, StaveNote, Voice, Formatter, TestNote} = Vex.Flow; 

        // For generator settings 
        let clefVal = 'percussion';  // percussion, treble, bass 
                                        // SET CLEF BY REFRESHING PAGE (HAVE A BUTTON FOR THIS) 


        // Create an SVG renderer and attach it to the DIV element named "generatedScore".
        const div = document.getElementById('generatedScore');
        const renderer = new Renderer(div, Renderer.Backends.SVG);

        // Configure the rendering context.
        renderer.resize(500, 500);
        const context = renderer.getContext();

        // Create a stave of width 420 at position 10, 40 on the canvas.
        const stave = new Stave(10, 40, 420);

        // Add a clef and time signature. // This will be dynamic later in generator settings algorithm 
        stave.addClef(clefVal).addTimeSignature('4/4');

        // Connect it to the rendering context and draw!
        stave.setContext(context).draw();





        // TODO: Add 16th notes and half notes 

        // I have left alot of console.logs for debugging, but will delete them later 


        // random notes in the future about this data: 
        // the contents of these three pools can by changed by generator settings 
        // in instrument catalog we'll have to include more note pools to represent different key signatures 

        // for now we're sticking to the key of C major/ A minor and 8th notes as the highest subdivision 
        
        let notePool = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; 
        let octavePool = ['/4', '/5'];              // excluding octaves 1-3 and 6-8 to prevent creating several ledger lines 
        let durationPool = ['q','8'];    // DELETE LATER, for testing   q = quarter notes, 8 = eigth notes 
            //durationPool = ['w', 'q','8', '16']   # USE THIS LATER 
        
        // Represents Snare Drum data 
        let snareDrumNotePool = ['C']; 
        let snareDrumOctavePool = ['/5']; 

        let randomIndex; 

        const notes = []; 
        let beatsTotal = 8;  // Total number of beats in the measure, will change this to make it dynamic later 
        // Store array for dynamically adding them to Voices 
        let storeArrayForVoices = []; 
        
        // For Feedback algorithm 
        let generatedNotesArray = []; 
        //For testing Sticking and Instrument Switching 
        let storeDruationForTextNote = []; 
        
        let randomNote; 
        let randomDuration; 

        function pickRandomArrayIndex(Array){   
        // ensure randomness with just 2 values in array 
        if (Array.length == 2){ 
            let randDecimalVal = Math.random(); // outputs decimal value, instead of whole number 
            randDecimalVal = randDecimalVal < 0.50 ? 0 : 1; 

            randomIndex = randDecimalVal; 
        }  
        else {
            randomIndex = Math.floor(Math.random() * Array.length) + 0; // subtracting 1 to match the max array index 
            if(randomIndex != 0){ // to prevent -1 index and undefined error 
                randomIndex--; 
            }
        }

        return randomIndex; 
        }

        function randomizeDuration(){
        let Duration = durationPool[pickRandomArrayIndex(durationPool)];  

        return Duration; 
        }



        function setBeatsLeftInMeasure (durationToSet) {
        if ( beatsTotal === 1 && durationToSet == 'q'){  // catches situation if beatsTotal = 1, but the note randomize is 'q' 
            beatsTotal = beatsTotal - 1; 
            return '8';     // Changes Duration so there's a sufficient number of notes in measure 
        }
        else if(durationToSet == 'q'){
            beatsTotal = beatsTotal - 2; 
        }
        else if (durationToSet == '8') {
            beatsTotal = beatsTotal - 1; 
        }
        }

        // creates the random Note and Duration then outputs it into Vexflow API 
        function createRandomNoteForGlock(){
            function randomizeNoteAndOctave(){
                let Note = notePool[pickRandomArrayIndex(notePool)];  
                let Octave = octavePool[pickRandomArrayIndex(octavePool)]; 
                // percussNoteHead = percussionNoteHeadPool[pickRandomArrayIndex(percussionNoteHeadPool)]; // TAKE OUT PERCUSSION STUFF, HAVE TO BE IF STATEMENT 

                // return Note + Octave + percussNoteHead; // TAKE OUT PERCUSSION STUFF, HAVE TO BE IF STATEMENT 
            return Note + Octave; //+ percussNoteHead  
            }

            randomNote = randomizeNoteAndOctave();  
            randomDuration =  randomizeDuration(); 
            storeDruationForTextNote[randomDuration]; // Stores duration for TextNote 

            if (beatsTotal === 1 && randomDuration === "q"){
            let durationInQuestion = randomDuration; 
            randomDuration = setBeatsLeftInMeasure(durationInQuestion); 
            }
            else{
                setBeatsLeftInMeasure (randomDuration); 
            }

          return new Vex.Flow.StaveNote ({
          keys: [randomNote],
          duration: randomDuration
        });
        }
      
        function createRandomNoteForSnareDrum(){
            function randomizeNoteAndOctaveForSnare(){
                let Note = snareDrumNotePool[pickRandomArrayIndex(snareDrumNotePool)];  
                let Octave = snareDrumOctavePool[pickRandomArrayIndex(snareDrumOctavePool)]; 
                // percussNoteHead = percussionNoteHeadPool[pickRandomArrayIndex(percussionNoteHeadPool)]; // TAKE OUT PERCUSSION STUFF, HAVE TO BE IF STATEMENT 

                // return Note + Octave + percussNoteHead; // TAKE OUT PERCUSSION STUFF, HAVE TO BE IF STATEMENT 
            return Note + Octave; //+ percussNoteHead  
            }
        
            randomNote = randomizeNoteAndOctaveForSnare();  
            randomDuration =  randomizeDuration(); 
            storeDruationForTextNote[randomDuration]; // Stores duration for TextNote 

            if (beatsTotal === 1 && randomDuration === "q"){
            let durationInQuestion = randomDuration; 
            randomDuration = setBeatsLeftInMeasure(durationInQuestion); 
            }
            else{
                setBeatsLeftInMeasure (randomDuration); 
            }

          return new Vex.Flow.StaveNote ({
          keys: [randomNote],
          duration: randomDuration
        });
        }
      




        

        while(beatsTotal != 0) {
        // randomNote = createRandomNoteForGlock(); 
        randomNote = createRandomNoteForSnareDrum(); 
            console.log(beatsTotal); 
        if (notes.length > 7){    // Catches error where generated notes surpass array limit, Will make this more dynamic 
            console.log("ERROR MAX ARRAY LIMIT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   " + notes.length); 
            break;  
        }
        else {
            notes.push(randomNote); // push created notes in array for vexflow to format and render to screen 
        }
        }
        storeArrayForVoices.push(notes); // store array for voices 

        // For Feedback Algorithm 
        // Show Stored Notes of Array in Console Log, DELETE LATER 
        let it = 0; 
        console.log("Array's Content that's storing Generated Notes: ")
        while (it < generatedNotesArray.length){
        console.log(generatedNotesArray[it]); 
        it++; 
        }

        /* const notes2 = [new StaveNote({
        keys: [randomizeNoteAndOctave()],  
        duration: 'w'
        })]; */

        const notes2 = [new StaveNote({  // hardcoding this BUT EDIT THIS LATER TO MAKE MORE DYNCAMIC 
        keys: ['E/4'],  
        duration: 'w'
        })];
        storeArrayForVoices.push(notes2); 


        // Use array that's storing the note duration in place of the TextNotes' durations 
        j = 0; 
        let testingTextNote = [
        // var text = new Vex.Flow.TextNote({ // Added TextNote at top, initially declare it here 
        
            new Vex.Flow.TextNote({ // Added TextNote at top, initially declare it here 
            text: "THIS IS A TEST",
            font: {
                family: "Arial",
                size: 12,
                weight: ""
            },
            duration: 'q'               
            })
            .setLine(-3) // -3 highest, 3 low (Increase context if needed)
            .setStave(stave)
            .setJustification(Vex.Flow.TextNote.Justification.CENTER),
            new Vex.Flow.TextNote({ // Added TextNote at top, initially declare it here 
            text: "R",
            font: {
                family: "Arial",
                size: 12,
                weight: ""
            },
            duration: 'q'               
            })
            .setLine(-3) // -3 highest, 3 low (Increase context if needed)
            .setStave(stave)
            .setJustification(Vex.Flow.TextNote.Justification.CENTER),
            new Vex.Flow.TextNote({ // Added TextNote at top, initially declare it here 
            text: "R",
            font: {
                family: "Arial",
                size: 12,
                weight: ""
            },
            duration: 'q'               
            })
            .setLine(-3) // -3 highest, 3 low (Increase context if needed)
            .setStave(stave)
            .setJustification(Vex.Flow.TextNote.Justification.CENTER),
            new Vex.Flow.TextNote({ // Added TextNote at top, initially declare it here 
            text: "R",
            font: {
                family: "Arial",
                size: 12,
                weight: ""
            },
            duration: 'q'               
            })
            .setLine(-3) // -3 highest, 3 low (Increase context if needed)
            .setStave(stave)
            .setJustification(Vex.Flow.TextNote.Justification.CENTER)

        ]
        storeArrayForVoices.push(testingTextNote); 

        const voices = []; 
            
        function addVoices(Array){
            console.log(Array); 
            return new Voice({
            num_beats: 4,
            beat_value: 4
            }).addTickables(Array);            
        }
        let tempVoiceVar = []; 

        for (let k = 0; k < storeArrayForVoices.length; k++){
            tempVoiceVar = addVoices(storeArrayForVoices[k]);
                console.log("TESTING THE tempVoiceVar " + tempVoiceVar); 
            voices.push(tempVoiceVar); 
        
            
        }
        
        /* // Create a voice in 4/4 and add above notes
        const voices = [
        new Voice({
            num_beats: 4,
            beat_value: 4
        }).addTickables(notes),
        new Voice({
            num_beats: 4,
            beat_value: 4
        }).addTickables(notes2),
        new Voice({
            num_beats: 4,
            beat_value: 4
        }).addTickables(testingTextNote), // added voice for TextNote 
        ]; */



        // voice2.addTickables([text]);   DELETE THIS LATER 


        // Format and justify the notes to 400 pixels.
        new Formatter().joinVoices(voices).format(voices, 350);

        // Render voices.
        voices.forEach(function(v) {
        v.draw(context, stave);
        });


        // Positioning score in middle of page 
        const scorePosition = document.getElementById('generatedScore');
        const centerScore = () => {
        scorePosition.style.marginLeft = window.innerWidth/1.75 - scorePosition.clientWidth/1.75 + 'px'; 
        scorePosition.style.marginTop = window.innerHeight/40- scorePosition.clientHeight/40 + 'px'; 
        }

        centerScore();
        window.addEventListener('resize', centerScore); 

    }
  
    </script>
  </body>
</html>
